#!/usr/bin/env bash
set -e

source /opt/ros/humble/setup.bash
source ~/scout_ws/install/setup.bash

XACRO=~/scout_ws/src/ugv_gazebo_sim/scout/scout_description/urdf/scout_v2.xacro

OUT_URDF=/tmp/scout_v2_dyn.urdf
OUT_GZ=/tmp/scout_v2_dyn_gazebo.urdf

echo "[scout_spawn_dyn] 1) Génère URDF depuis xacro..."
xacro "$XACRO" > "$OUT_URDF"

echo "[scout_spawn_dyn] 2) Patch URDF -> Gazebo (file:// + plugins)..."
python3 - <<'PY'
from pathlib import Path
import re

share = Path.home() / "scout_ws/install/scout_description/share/scout_description"
p_in  = Path("/tmp/scout_v2_dyn.urdf")
p_out = Path("/tmp/scout_v2_dyn_gazebo.urdf")

txt = p_in.read_text()

# 1) URIs mesh: package:// + model:// -> file://
txt = txt.replace("package://scout_description/", f"file://{share.as_posix()}/")
txt = txt.replace("model://scout_description/",   f"file://{share.as_posix()}/")

# 2) PATCH joints: fixed -> continuous (sinon Gazebo les supprime, diff_drive ne les trouve pas)
for j in ["front_left_wheel", "front_right_wheel", "rear_left_wheel", "rear_right_wheel"]:
    txt = re.sub(
        rf'(<joint\s+name="{j}"\s+type=")fixed(")',
        r'\1continuous\2',
        txt
    )
# 2bis) PATCH AXIS : inverser l'axe des roues droites (sinon avance <-> tourne)
def flip_right_wheel_axis(txt, joint_name):
    # remplace uniquement dans le bloc du joint ciblé
    pattern = rf'(<joint\s+name="{joint_name}"[\s\S]*?<axis[^>]*xyz=")([^"]+)(")'
    m = re.search(pattern, txt)
    if not m:
        return txt
    xyz = m.group(2).strip().split()
    if len(xyz) == 3:
        # on inverse juste Y (0 -1 0 -> 0 1 0)
        try:
            y = float(xyz[1])
            xyz[1] = str(-y).rstrip('0').rstrip('.') if '.' in str(-y) else str(-y)
        except:
            pass
    repl = m.group(1) + " ".join(xyz) + m.group(3)
    return re.sub(pattern, repl, txt, count=1)

txt = flip_right_wheel_axis(txt, "front_right_wheel")
txt = flip_right_wheel_axis(txt, "rear_right_wheel")

# 3) SUPPRIMER plugins qui cassent tout / conflit
# - ros_control / ros2_control
txt = re.sub(r"<gazebo>\s*<plugin[^>]*filename=\"libgazebo_ros_control\.so\".*?</plugin>\s*</gazebo>\s*", "", txt, flags=re.S)
txt = re.sub(r"<gazebo>\s*<plugin[^>]*filename=\"libgazebo_ros2_control\.so\".*?</plugin>\s*</gazebo>\s*", "", txt, flags=re.S)
# - skid steer (ROS1)
txt = re.sub(r"<gazebo>\s*<plugin[^>]*filename=\"libgazebo_ros_skid_steer_drive\.so\".*?</plugin>\s*</gazebo>\s*", "", txt, flags=re.S)
# - planar_move (TRÈS IMPORTANT : sinon il se bat avec diff_drive)
txt = re.sub(r"<gazebo>\s*<plugin[^>]*filename=\"libgazebo_ros_planar_move\.so\".*?</plugin>\s*</gazebo>\s*", "", txt, flags=re.S)

# 4) Injecter deux diff_drive (front publie odom, rear non)
plugin_block = r"""
  <gazebo>
    <plugin name="scout_diff_drive_front" filename="libgazebo_ros_diff_drive.so">
      <ros>
        <namespace>/</namespace>
        <remapping>cmd_vel:=/cmd_vel</remapping>
        <remapping>odom:=/odom</remapping>
      </ros>

      <update_rate>50</update_rate>

      <!-- AVANT -->
      <left_joint>front_left_wheel</left_joint>
      <right_joint>front_right_wheel</right_joint>

      <wheel_separation>0.583</wheel_separation>
      <wheel_diameter>0.32918</wheel_diameter>

      <!-- LUI publie odom/tf -->
      <publish_odom>true</publish_odom>
      <publish_odom_tf>true</publish_odom_tf>
      <odometry_frame>odom</odometry_frame>
      <robot_base_frame>base_footprint</robot_base_frame>

      <cmd_vel_timeout>0.25</cmd_vel_timeout>
    </plugin>
  </gazebo>

  <gazebo>
    <plugin name="scout_diff_drive_rear" filename="libgazebo_ros_diff_drive.so">
      <ros>
        <namespace>/</namespace>
        <remapping>cmd_vel:=/cmd_vel</remapping>
      </ros>

      <update_rate>50</update_rate>

      <!-- ARRIÈRE -->
      <left_joint>rear_left_wheel</left_joint>
      <right_joint>rear_right_wheel</right_joint>

      <wheel_separation>0.583</wheel_separation>
      <wheel_diameter>0.32918</wheel_diameter>

      <!-- IMPORTANT : pas d’odom/tf ici -->
      <publish_odom>false</publish_odom>
      <publish_odom_tf>false</publish_odom_tf>

      <cmd_vel_timeout>0.25</cmd_vel_timeout>
    </plugin>
  </gazebo>

  <gazebo>
    <plugin name="joint_state_pub" filename="libgazebo_ros_joint_state_publisher.so">
      <ros>
        <namespace>/</namespace>
        <remapping>joint_states:=/joint_states</remapping>
      </ros>

      <update_rate>50</update_rate>
      <joint_name>front_left_wheel</joint_name>
      <joint_name>front_right_wheel</joint_name>
      <joint_name>rear_left_wheel</joint_name>
      <joint_name>rear_right_wheel</joint_name>
    </plugin>
  </gazebo>
"""

# Injecte juste avant </robot> si pas déjà présent
if 'name="scout_diff_drive_front"' not in txt:
    txt = txt.replace("</robot>", plugin_block + "\n</robot>")

p_out.write_text(txt)
print("OK wrote", p_out)

# Mini debug: lister plugins présents
plugins = re.findall(r'filename="(libgazebo_ros_[^"]+\.so)"', txt)
print("Plugins in URDF:", sorted(set(plugins)))
PY

echo "[scout_spawn_dyn] 3) Delete ancien modèle (si présent)..."
ros2 service call /delete_entity gazebo_msgs/srv/DeleteEntity "{name: 'scout_v2_dyn'}" >/dev/null 2>&1 || true
ros2 service call /delete_entity gazebo_msgs/srv/DeleteEntity "{name: 'scout_v2'}" >/dev/null 2>&1 || true

echo "[scout_spawn_dyn] 4) Spawn..."
ros2 run gazebo_ros spawn_entity.py \
  -entity scout_v2_dyn \
  -file "$OUT_GZ" \
  -x 0 -y 0 -z 0.40

echo "[scout_spawn_dyn] OK"
